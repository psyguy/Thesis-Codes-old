if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
View(rewired)
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps)
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * inp.x[i_]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
x.temp <- inp.x
x.temp <- inp.x <- x
conn <- inp.conn <- conn
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps)
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps)
# eps: coupling strength
inp.dim <- x.input %>% dim()
# eps: coupling strength
inp.dim <- x.inp %>% dim()
# eps: coupling strength
inp.dim <- inp.x %>% dim()
inp.dim <- inp.x %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- inp.x[,leng]
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
inp.dim <- inp.x %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- inp.x[,leng]
if(is.null(height)) height <- inp.x %>% length()
if(is.null(leng)) x.now <- inp.x
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1(a = a) %>% as.matrix()
fx <- x.now %>% func.1(a = a) %>% as.matrix()
fx <- x.now %>% func.1(a = a) %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
if(is.null(leng)) x.now <- inp.x
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
p <- c(7,3)
func.1(p)
49*17
(1 - eps)*fx
connectivity.matrix
fx*eps
fx*eps / M
M
connectivity.matrix %*% fx*eps / M
(1 - eps)*fx
x.next
x.now <- x.next
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1(a = a) %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
x.next
x.temp <- inp.x
conn <- inp.conn <- conn
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
distances
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * inp.x[i_]) %>% which.max()
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
i_
d_
k_
d_[i_] <- NULL
d_[-i_]
k_ <- which.min(d_[-i_])
k_
k_val <- min(d_[-i_])
?which
d_==k_val
k_ <- which(d_==k_val)
l_ <- (d_ * inp.x[i_]) %>% which.max()
!conn[i_,k_]
conn[i_,k_]
inp.x[i_]
(d_ * inp.x)
View(conn)
d_
inp.x
d_ * conn[i_]
conn[i_]
d_ * conn[i_,]
(d_ * conn[i_,]) %>% which.max()
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
if(!conn[i_,k_]) conn <- conn %>% swap.edge()
conn
conn <- conn %>% swap.edge()
conn
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
conn
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
conn
k_val
k_
l_
d_
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
conn
conn %>% sum() %>% sum
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
clustering.coef
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 10#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[3], seed = 1)
save(current.status, file = "current.status.20180224.2.RData")
seed <- 1
set.seed(seed)
num.edges <- 7#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
conn
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
View(rewired)
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef)
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef)
rewired <- NULL
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef)
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
#(clustering.coef[iterations] <- rewired$clustering.coef)
}
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
#(clustering.coef[iterations] <- rewired$clustering.coef)
}
rewired <- NULL
clustering.coef <- NULL
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
x
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g, type = "average")
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
?transitivity
time.end <- Sys.time()
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 7#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
rewired <- NULL
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix)
(clustering.coef[iterations] <- rewired$clustering.coef)
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[3], seed = 1)
save(current.status, file = "current.status.20180225.RData")
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix)
(clustering.coef[iterations] <- rewired$clustering.coef)
}
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix) %>% print()
(clustering.coef[iterations] <- rewired$clustering.coef) %>% print()
}
c(a1,a2) <- c(2,8)
c(a1,a2) <- c(2,8)
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g, type = "local")
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix) %>% print()
(clustering.coef[iterations] <- rewired$clustering.coef) %>% print()
}
?rewire
!conn[i_,k_]&T
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]&T) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g, type = "local")
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 7#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
rewired <- NULL
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix) %>% print()
(clustering.coef[iterations] <- rewired$clustering.coef) %>% print()
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[3], seed = 1)
save(current.status, file = "current.status.20180225.RData")
