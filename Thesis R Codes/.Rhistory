adj.matrix %>% return()
}
my.rewiring <- function(x.now, adj.matrix, optionals){
x.temp <- x.now
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn)
x.now <- x.temp
distances <- Hellrigel2019.syncerror(x.now, connectivity.matrix = conn)
num.nodes <- dim(adj.matrix)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * x.now[i_]) %>% which.max()
if(!conn[i_,j_1]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
output <- list(x = x.now, Connectivity.Matrix = conn)
output %>% return()
}
my.rewiring <- function(x.now, adj.matrix){
x.temp <- x.now
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn)
x.now <- x.temp
distances <- Hellrigel2019.syncerror(x.now, connectivity.matrix = conn)
num.nodes <- dim(adj.matrix)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * x.now[i_]) %>% which.max()
if(!conn[i_,j_1]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
output <- list(x = x.now, Connectivity.Matrix = conn)
output %>% return()
}
epochs <- 10
num.epochs <- 10
rewired <- list(x = x.now, Connectivity.Matrix = conn)
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20 %>% as.vector()
num.epochs <- 10
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
rewired <- list(x = x.now, Connectivity.Matrix = conn)
my.rewiring <- function(x.now, Connectivity.Matrix){
x.temp <- x.now
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn)
x.now <- x.temp
distances <- Hellrigel2019.syncerror(x.now, connectivity.matrix = conn)
num.nodes <- dim(adj.matrix)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * x.now[i_]) %>% which.max()
if(!conn[i_,j_1]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
output <- list(x = x.now, Connectivity.Matrix = conn)
output %>% return()
}
?transitivity
g <- graph_from_adjacency_matrix(rewired$Connectivity.Matrix, mode = "undirected")
Clustering.Coef <- transitivity(g)
my.rewiring <- function(x.now, connectivity.matrix){
x.temp <- x.now
con <- Connectivity.Matrix
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn)
distances <- Hellrigel2019.syncerror(x.now, connectivity.matrix = conn)
num.nodes <- dim(adj.matrix)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * x.now[i_]) %>% which.max()
if(!conn[i_,j_1]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(rewired$conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.now, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
my.rewiring <- function(x.now, connectivity.matrix){
x.temp <- x.now
con <- Connectivity.Matrix
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn)
distances <- Hellrigel2019.syncerror(x.now, connectivity.matrix = conn)
num.nodes <- dim(adj.matrix)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * x.now[i_]) %>% which.max()
if(!conn[i_,j_1]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(rewired$conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.now, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
rewired <- list(x = x.now, Connectivity.Matrix = conn)
x <- x.init
conn <- conn
clustering.coef <- NULL
for(iterations in 1:num.epochs){
rewired <- my.rewiring(x.now = x, connectivity.matrix = connectivity.matrix)
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
rewired <- list(x = x.now, connectivity.matrix = conn)
x <- x.init
conn <- conn
clustering.coef <- NULL
for(iterations in 1:num.epochs){
rewired <- my.rewiring(x.now = x, connectivity.matrix = connectivity.matrix)
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
my.rewiring <- function(x.now, connectivity.matrix){
x.temp <- x.now
con <- connectivity.matrix
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn)
distances <- Hellrigel2019.syncerror(x.now, connectivity.matrix = conn)
num.nodes <- dim(adj.matrix)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * x.now[i_]) %>% which.max()
if(!conn[i_,j_1]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(rewired$conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.now, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
rewired <- list(x = x.now, connectivity.matrix = conn)
x <- x.init
conn <- conn
clustering.coef <- NULL
for(iterations in 1:num.epochs){
rewired <- my.rewiring(x.now = x, connectivity.matrix = connectivity.matrix)
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
#rewired <- list(x = x.now, connectivity.matrix = conn)
x <- x.init
conn <- conn
clustering.coef <- NULL
for(iterations in 1:num.epochs){
rewired <- my.rewiring(x.now = x, connectivity.matrix = connectivity.matrix)
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
my.rewiring <- function(inp.x, inp.conn){
x.temp <- inp.x
conn <- inp.conn
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn)
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(adj.matrix)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * inp.x[i_]) %>% which.max()
if(!conn[i_,j_1]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(rewired$conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
#rewired <- list(x = x.now, connectivity.matrix = conn)
x <- x.init
conn <- conn
clustering.coef <- NULL
for(iterations in 1:num.epochs){
rewired <- my.rewiring(x.now = x, connectivity.matrix = connectivity.matrix)
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
clustering.coef <- NULL
for(iterations in 1:num.epochs){
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix)
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
connectivity.matrix <- conn
clustering.coef <- NULL
for(iterations in 1:num.epochs){
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix)
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
plot(clustering.coef)
rm(list=ls())
eps = eps[1]
eps <- c(0.3, 0.4, 0.5)
eps = eps[1]
eps
seed <- 1
set.seed(seed)
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20 %>% as.vector()
num.epochs <- 50000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
x <- x.init
connectivity.matrix <- conn
mod(1423,10)
12 mod 3
12 %% 3
12 %% 7
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20 %>% as.vector()
num.epochs <- 50000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(iterations %% 100) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix, eps = eps[1])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
eps <- c(0.3, 0.4, 0.5)
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix, eps = eps[1])
my.rewiring <- function(inp.x, inp.conn, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps)
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(adj.matrix)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * inp.x[i_]) %>% which.max()
if(!conn[i_,j_1]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(rewired$conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20 %>% as.vector()
num.epochs <- 50000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(iterations %% 100) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix, eps = eps[1])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
my.rewiring <- function(inp.x, inp.conn, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps)
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * inp.x[i_]) %>% which.max()
if(!conn[i_,j_1]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(rewired$conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20 %>% as.vector()
num.epochs <- 50000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(iterations %% 100) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix, eps = eps[1])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
my.rewiring <- function(inp.x, inp.conn, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps)
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * inp.x[i_]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(rewired$conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20 %>% as.vector()
num.epochs <- 50000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(iterations %% 100) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix, eps = eps[1])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
my.rewiring <- function(inp.x, inp.conn, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps)
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_ <- which.min(d_)
l_ <- (d_ * inp.x[i_]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge()
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20 %>% as.vector()
num.epochs <- 50000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(iterations %% 100) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix, eps = eps[1])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
rm(list = ls())
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20 %>% as.vector()
num.epochs <- 50000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix, eps = eps[1])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, seed = 1)
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, seed = 1)
save(current.status, file = "current.status.20180224.RData")
plot(clustering.coef)
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[1], seed = 1)
save(current.status, file = "current.status.20180224.RData")
rm(list=ls())
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20 %>% as.vector()
num.epochs <- 10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.now <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[3], seed = 1)
save(current.status, file = "current.status.20180224.2.RData")
plot(clustering.coef)
plot(clustering.coef)
