hight <- inp.dim[1]
leng <- inp.dim[2]
x.now <- x.input[,leng]
x.duplicated <- x.now
for (i in 1:(hight-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
d %>% return()
}
distances <- GongvLeeuwen2004.coherenceD(x.out[,T_+1],connectivity.matrix = conn)
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(hight-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
d %>% return()
}
distances <- GongvLeeuwen2004.coherenceD(x.out[,T_+1],connectivity.matrix = conn)
library(dplyr)
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
d %>% return()
}
distances <- GongvLeeuwen2004.coherenceD(x.out,connectivity.matrix = conn)
set.seed(seed)
i_ <- sample.int(N,1)
d_ <- distances[,i_]
j_2 <- max(d_)
j_1 <- min(d_)
d_ %>% max() %>% max()
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
diag(d) <- 1
d %>% return()
}
d_ <- distances[,i_]
j_1 <- min(d_)
j_2 <- max(d_)
d_ <- distances[,i_]
j_1 <- min(d_)
j_2 <- max(d_)
View(distances)
library(dplyr)
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
d %>% return()
}
d_ <- distances[,i_]
d_ <- d_[-i_]
j_1 <- min(d_)
j_2 <- max(d_)
?which.min
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
diag(d) <- NA
d %>% return()
}
d_ <- distances[,i_]
j_1 <- which.min(d_)
j_2 <- which.max(d_)
d_[i_]
diag(d) <- NA
d %>% return()
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
diag(d) <- NA
d %>% return()
}
View(distances)
distances <- GongvLeeuwen2004.coherenceD(x.out,connectivity.matrix = conn)
i_ <- sample.int(N,1)
d_ <- distances[,i_]
j_1 <- which.min(d_)
j_2 <- which.max(d_)
i_ <- sample.int(N,1)
d_ <- distances[,i_]
j_1 <- which.min(d_)
j_2 <- which.max(d_)
distances
distances[]
distances[i_,i_]
distances[i_,i_+1]
swap.edge <- function(connectivity.matrix, i1, j1, i2, j2){
edge.1 <- connectivity.matrix[i1,j1]
edge.2 <- connectivity.matrix[i2,j2]
connectivity.matrix[i1,j1] <- edge.2
connectivity.matrix[j1,i1] <- edge.2
connectivity.matrix[i2,j2] <- edge.1
connectivity.matrix[j2,i2] <- edge.1
connectivity.matrix %>% return()
}
library(dplyr)
swap.edge <- function(connectivity.matrix, i1, j1, i2, j2){
edge.1 <- connectivity.matrix[i1,j1]
edge.2 <- connectivity.matrix[i2,j2]
connectivity.matrix[i1,j1] <- edge.2
connectivity.matrix[j1,i1] <- edge.2
connectivity.matrix[i2,j2] <- edge.1
connectivity.matrix[j2,i2] <- edge.1
connectivity.matrix %>% return()
}
if(!conn[i_,j_1]) conn <- conn %>% swap.edge(i1 = i_, j1 = j_1, i2 = i_, j2 = j_2)
install.packages("igraph")
library(igraph)
graph_from_adjacency_matrix(conn, mode = "undirected")
g <- graph_from_adjacency_matrix(conn, mode = "undirected")
View(g)
g[[1]][[1]]
ClCoef <- transitivity(g)
ClCoef
tol <- 0.001
library(dplyr)
install.packages("igraph")
library(igraph)
load("~/KUL/MPsy/Thesis - Stable/Thesis-Codes/Thesis R Codes/x.out_5200.300.6000.Rdata")
View(x.out)
View(x.out)
View(distances)
View(distances)
View(distances)
distances[1,2]
source('~/KUL/MPsy/Thesis - Stable/Thesis-Codes/Thesis R Codes/Functions/GongvLeeuwen2004.logistic.R')
rm(list=ls())
library(dplyr)
Hellrigel2019.logistic <- function(x.input, connectivity.matrix, a = 1.7, eps = 0.8, order = 0){
# eps: coupling strength
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
# Higher orders are not implemented yet
#if(order) x <- x.input[,len-order:len]
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1(a = a) %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
x.next %>% return()
}
func.1 <- function(x, a = 1.7){1 - a*(x^2)}
library(dplyr)
Hellrigel2019.syncerror <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
diag(d) <- NA
d %>% return()
}
library(dplyr)
Hellrigel2019.syncerror <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
diag(d) <- 0
d %>% return()
}
seed <- 1
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20
T_ <- 6000
rm(T_)
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges, seed = seed, dist = "binary")
make.random.graph <- function(size = 20, num.links = 100, distribution = "binary",
parameters = c(0,1), seed = 1){
set.seed(seed)
if(distribution == "binary")   vals <- sample.int(size ^ 2, num.links + size)
diagonals <- c(1:size)#cbind(1:size,1:size)
edge.list <- cbind(vals %/% size + 0, vals %% size + 1)
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
edge.list <- edge.list %>% na.omit()
# edge.list <- edge.list[1:num.links,]
#
# edge.list <- unique(edge.list[ , 1:2 ] )
edge.list.rev <- edge.list[,2] %>% cbind(edge.list[,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
adj.matrix <- matrix(0, size, size)
adj.matrix[edge.list.symmetric] <- 1
# adj.matrix %>% sum() %>% sum()
#
# diag(adj.matrix)
adj.matrix %>% return()
}
conn <- make.random.graph(size = num.nodes, num.links = num.edges, dist = "binary", seed = seed)
View(conn)
conn %>% sum() %>% sum()
size = 20
num.links
num.links = 100
vals <- sample.int(size ^ 2, num.links + size)
diagonals <- c(1:size)#cbind(1:size,1:size)
edge.list <- cbind(vals %/% size + 0, vals %% size + 1)
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
edge.list <- edge.list %>% na.omit()
edge.list <- (edge.list %>% na.omit())[1:num.links,]
edge.list.rev <- edge.list[,2] %>% cbind(edge.list[,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
edge.list <- cbind(vals %/% size + 0, vals %% size + 1)
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
edge.list <- (edge.list %>% na.omit())
edge.list <- (edge.list %>% na.omit())
edge.list.rev <- edge.list[,2] %>% cbind(edge.list[,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
edge.list <- (edge.list %>% na.omit())[1:num.links,] %>% arrange(1)
edge.list <- (edge.list %>% na.omit())[1:num.links,] %>% sort(1)
edge.list <- (edge.list %>% na.omit())[1:num.links,] %>% sort()
edge.list <- cbind(vals %/% size + 0, vals %% size + 1) %>% arrange(1)
edge.list <- cbind(vals %/% size + 0, vals %% size + 1)
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
edge.list <- edge.list %>% na.omit()#)[1:num.links,]
n.e <- dim(edge.list)[1]
edge.list.rev <- edge.list[n.e:1,2] %>% cbind(edge.list[n.e:1,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
edge.list.rev <- edge.list[n.e:1,2] %>% cbind(edge.list[n.e:1,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
length.edge.list <- dim(edge.list.symmetric)[2]
length.edge.list <- dim(edge.list.symmetric)[1]
length.edge.list <- dim(edge.list.symmetric)[1]/2
length.diff <- dim(edge.list.symmetric)[1]/2 - num.links
edge.list.final <- edge.list.final[(1+length.diff):(num.links-length.diff)]
edge.list.final <- edge.list.symmetric[(1+length.diff):(num.links-length.diff)]
num.links-length.diff
edge.list.final <- edge.list.symmetric[(1+length.diff):(num.links-length.diff),]
(1+length.diff)
(num.links-length.diff)
l.e <- dim(edge.list.symmetric)[1]/2
length.diff <- l.e - num.links
edge.list.final <- edge.list.symmetric[(1+length.diff):(l.e-length.diff),]
l.e
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
edge.list <- cbind(vals %/% size + 0, vals %% size + 1)
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
edge.list <- edge.list %>% na.omit()#)[1:num.links,]
n.e <- dim(edge.list)[1]
edge.list.rev <- edge.list[n.e:1,2] %>% cbind(edge.list[n.e:1,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
l.e <- dim(edge.list.symmetric)[1]/2
length.diff <- l.e - num.links
edge.list.final <- edge.list.symmetric[(1+length.diff):(l.e-length.diff),]
adj.matrix <- matrix(0, size, size)
adj.matrix[edge.list.symmetric] <- 1
edge.list.symmetric[1,] <- NULL
library(dplyr)
library("Hmisc")
make.random.graph <- function(size = 20, num.links = 100, distribution = "binary",
parameters = c(0,1), seed = 1){
set.seed(seed)
if(distribution == "binary") vals <- sample.int(size ^ 2, num.links + size)
diagonals <- c(1:size)#cbind(1:size,1:size)
edge.list <- cbind(vals %/% size + 0, vals %% size + 1)
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
edge.list <- edge.list %>% na.omit()#)[1:num.links,]
n.e <- dim(edge.list)[1]
# edge.list <- edge.list[1:num.links,]
#
# edge.list <- unique(edge.list[ , 1:2 ] )
edge.list.rev <- edge.list[n.e:1,2] %>% cbind(edge.list[n.e:1,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
# l.e <- dim(edge.list.symmetric)[1]/2
#
# while(num.links < l.e){
#
#
#
# }
#
#
# length.diff <- l.e - num.links
#
# edge.list.final <- edge.list.symmetric[(1+length.diff):(l.e-length.diff),]
adj.matrix <- matrix(0, size, size)
adj.matrix[edge.list.symmetric] <- 1
# adj.matrix %>% sum() %>% sum()
#
# diag(adj.matrix)
adj.matrix %>% return()
}
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
conn %>% sum() %>% sum()
conn %>% sum() %>% sum() %>% ./
2
seed <- 1
set.seed(seed)
x.init <- t.transient %>% runif(-1,1)
x.out <- x.init
for (i in 1:t.transient) {
x.temp <- x.out %>% Hellrigel2019.logistic(conn)
x.out <- x.out %>% cbind(x.temp)
}
for (i in 1:t.transient) {
x.temp <- x.out %>% Hellrigel2019.logistic(conn)
x.out <- x.out %>% cbind(x.temp)
}
a = 1.7
eps = 0.8
connectivity.matrix <- connectivity.matrix
x.init <- num.nodes %>% runif(-1,1)
x.out <- x.init
for (i in 1:t.transient) {
x.temp <- x.out %>% Hellrigel2019.logistic(conn)
x.out <- x.out %>% cbind(x.temp)
}
library(dplyr)
Hellrigel2019.logistic <- function(x.input, connectivity.matrix, a = 1.7, eps = 0.8, order = 0){
# eps: coupling strength
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
# Higher orders are not implemented yet
#if(order) x <- x.input[,len-order:len]
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1(a = a) %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
x.next %>% return()
}
func.1 <- function(x, a = 1.7){1 - a*(x^2)}
x.init <- num.nodes %>% runif(-1,1)
set.seed(seed)
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
x.out <- x.init
for (i in 1:t.transient) {
x.temp <- x.out %>% Hellrigel2019.logistic(conn)
x.out <- x.out %>% cbind(x.temp)
}
distances <- GongvLeeuwen2004.coherenceD(x.out,connectivity.matrix = conn)
library(dplyr)
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
diag(d) <- NA
d %>% return()
}
distances <- GongvLeeuwen2004.coherenceD(x.out,connectivity.matrix = conn)
View(distances)
library(dplyr)
Hellrigel2019.syncerror <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
diag(d) <- 0
d %>% return()
}
distances <- Hellrigel2019.syncerror(x.out,connectivity.matrix = conn)
View(distances)
View(distances)
i_ <- sample.int(N,1)
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
d_ <- d_[i_]
d_ <- distances[,i_]
d_ <- d_[i_]
d_ <- distances[,i_]
list.of.packages <- c("tidyverse", "dplyr", "plyr", "Hmisc")
list.of.packages <- c("tidyverse", "dplyr", "plyr", "Hmisc")
function.path <- "./My Thesis Functions/"
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)){install.packages(new.packages)}
l_ply(list.of.packages, require, character.only = TRUE)
my.scripts <- list.files(path = function.path, pattern = "*.R")
my.scripts <- my.scripts[my.scripts!="my.library.loader.R"]
l_ply(paste0(function.path,my.scripts), source)
rm(function.path,list.of.packages,my.scripts, new.packages)
list.of.packages <- c("tidyverse", "dplyr", "plyr", "Hmisc")
function.path <- "./My Thesis Functions/"
library(plyr)
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)){install.packages(new.packages)}
l_ply(list.of.packages, require, character.only = TRUE)
my.scripts <- list.files(path = function.path, pattern = "*.R")
my.scripts <- my.scripts[my.scripts!="my.library.loader.R"]
l_ply(paste0(function.path,my.scripts), source)
rm(function.path,list.of.packages,my.scripts, new.packages)
source("./My Thesis Functions/my.library.loader.R")
source("./My Thesis Functions/my.library.loader.R")
distances <- Hellrigel2019.syncerror(x.out,connectivity.matrix = conn)
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
d_ <- d_[i_]
d_ <- distances[,i_]
j_1 <- which.min(d_)
j_2 <- which.max(d_)
xx <- d_ * conn
xx <- d_ * conn[i_,]
l_ <- which.max(d_)
282
l_ <- which.max(xx)
conn(i_,282)
conn[i_,282]
conn[i_,274]
xx <- d_ * x.out[i_,]
d_ %>% summary
l_ <- d_ * x.out[i_,] %>% which.max()
l_ <- (d_ * x.out[i_,]) %>% which.max()
# Skipped step 5 probabilistic approach
conn <- conn %>% swap.edge()
g <- graph_from_adjacency_matrix(conn, mode = "undirected")
ClCoef <- transitivity(g)
