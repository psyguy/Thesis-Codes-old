# Higher orders are not implemented yet
#if(order) x <- x.input[,len-order:len]
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, hight, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1() %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
x.next %>% return()
}
for (i in 1:T_) {
x <- x.out %>% GongvLeeuwen2004.logistic(conn)
x.out <- x %>% cbind(x)
}
x.init <- N %>% runif(-1,1)
x.out <- x.init
for (i in 1:T_) {
x <- x.out %>% GongvLeeuwen2004.logistic(conn)
x.out <- x %>% cbind(x)
}
# eps: coupling strength
x.input <- x.init
inp.dim <- x.input %>% dim()
hight <- inp.dim[1]
leng <- inp.dim[2]
x.now <- x.input[,leng]
if(is.null(leng)) leng <- 1
x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
# eps: coupling strength
x.input <- x.init
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
else  x.now <- x.input[,leng]
if(is.null(leng)) {x.now <- x.input}
else  x.now <- x.input[,leng]
# eps: coupling strength
x.input <- x.init
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1() %>% as.matrix()
connectivity.matrix <- conn
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1() %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
eps = 0.8
a = 1.7
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1() %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
library(dplyr)
GongvLeeuwen2004.logistic <- function(x.input, connectivity.matrix, a = 1.7, eps = 0.8, order = 0){
# eps: coupling strength
x.input <- x.init
connectivity.matrix <- conn
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
# Higher orders are not implemented yet
#if(order) x <- x.input[,len-order:len]
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1() %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
x.next %>% return()
}
func.1 <- function(x, a = 1.7){1 - a*(x^2)}
library(dplyr)
GongvLeeuwen2004.logistic <- function(x.input, connectivity.matrix, a = 1.7, eps = 0.8, order = 0){
# eps: coupling strength
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
# Higher orders are not implemented yet
#if(order) x <- x.input[,len-order:len]
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1() %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
x.next %>% return()
}
func.1 <- function(x, a = 1.7){1 - a*(x^2)}
L_c <- 5200
N <- 300
T_ <- 1000
conn <- make.random.graph(size = N, num.links = L_c)
x.init <- N %>% runif(-1,1)
x.out <- x.init
for (i in 1:T_) {
x <- x.out %>% GongvLeeuwen2004.logistic(conn)
x.out <- x %>% cbind(x)
}
View(x.out)
L_c <- 5200
N <- 300
T_ <- 1000
conn <- make.random.graph(size = N, num.links = L_c)
x.init <- N %>% runif(-1,1)
x.out <- x.init
for (i in 1:T_) {
x.temp <- x.out %>% GongvLeeuwen2004.logistic(conn)
x.out <- x.out %>% cbind(x.temp)
}
View(x.out)
x.out %>% dim
rm(list=ls())
save.image
save.image()
library(dplyr)
L_c <- 5200
N <- 300
T_ <- 6000
conn <- make.random.graph(size = N, num.links = L_c)
x.init <- N %>% runif(-1,1)
x.out <- x.init
for (i in 1:T_) {
x.temp <- x.out %>% GongvLeeuwen2004.logistic(conn)
x.out <- x.out %>% cbind(x.temp)
}
library(dplyr)
GongvLeeuwen2004.logistic <- function(x.input, connectivity.matrix, a = 1.7, eps = 0.8, order = 0){
# eps: coupling strength
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
# Higher orders are not implemented yet
#if(order) x <- x.input[,len-order:len]
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1() %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
x.next %>% return()
}
func.1 <- function(x, a = 1.7){1 - a*(x^2)}
library(dplyr)
library("Hmisc")
make.random.graph <- function(size = 20, num.links = 100){
vals <- sample.int(size ^ 2, num.links + size)
diagonals <- c(1:size)#cbind(1:size,1:size)
edge.list <- cbind(vals %/% size + 0, vals %% size + 1)
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
edge.list <- edge.list %>% na.omit()
# edge.list <- edge.list[1:num.links,]
#
# edge.list <- unique(edge.list[ , 1:2 ] )
edge.list.rev <- edge.list[,2] %>% cbind(edge.list[,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
adj.matrix <- matrix(0, size, size)
adj.matrix[edge.list.symmetric] <- 1
# adj.matrix %>% sum() %>% sum()
#
# diag(adj.matrix)
adj.matrix %>% return()
}
library(dplyr)
L_c <- 5200
N <- 300
T_ <- 6000
conn <- make.random.graph(size = N, num.links = L_c)
x.init <- N %>% runif(-1,1)
x.out <- x.init
for (i in 1:T_) {
x.temp <- x.out %>% GongvLeeuwen2004.logistic(conn)
x.out <- x.out %>% cbind(x.temp)
}
library(dplyr)
library("Hmisc")
make.random.graph <- function(size = 20, num.links = 100, seed = 1){
set.seed(seed)
vals <- sample.int(size ^ 2, num.links + size)
diagonals <- c(1:size)#cbind(1:size,1:size)
edge.list <- cbind(vals %/% size + 0, vals %% size + 1)
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
edge.list <- edge.list %>% na.omit()
# edge.list <- edge.list[1:num.links,]
#
# edge.list <- unique(edge.list[ , 1:2 ] )
edge.list.rev <- edge.list[,2] %>% cbind(edge.list[,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
adj.matrix <- matrix(0, size, size)
adj.matrix[edge.list.symmetric] <- 1
# adj.matrix %>% sum() %>% sum()
#
# diag(adj.matrix)
adj.matrix %>% return()
}
seed <- 1
x.init <- N %>% runif(-1,1)
x.init <- N %>% runif(-1,1)
seed <- 1
x.init <- N %>% runif(-1,1)
seed <- 1
x.init <- N %>% runif(-1,1)
seed <- 1
x.init <- N %>% runif(-1,1)
seed <- 1
x.init <- N %>% runif(-1,1)
set.seed(seed)
x.init <- N %>% runif(-1,1)
conn <- make.random.graph(size = N, num.links = L_c, seed = seed)
x.init <- N %>% runif(-1,1)
x.out <- x.init
x.init <- N %>% runif(-1,1)
set.seed(seed)
x.init <- N %>% runif(-1,1)
set.seed(seed)
x.init <- N %>% runif(-1,1)
library(dplyr)
library("Hmisc")
make.random.graph <- function(size = 20, num.links = 100, seed = 1){
set.seed(seed)
vals <- sample.int(size ^ 2, num.links + size)
diagonals <- c(1:size)#cbind(1:size,1:size)
edge.list <- cbind(vals %/% size + 0, vals %% size + 1)
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
edge.list <- edge.list %>% na.omit()
# edge.list <- edge.list[1:num.links,]
#
# edge.list <- unique(edge.list[ , 1:2 ] )
edge.list.rev <- edge.list[,2] %>% cbind(edge.list[,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
adj.matrix <- matrix(0, size, size)
adj.matrix[edge.list.symmetric] <- 1
# adj.matrix %>% sum() %>% sum()
#
# diag(adj.matrix)
adj.matrix %>% return()
}
system.time()
system.time()
Sys.time()
for (i in 1:T_) {
x.temp <- x.out %>% GongvLeeuwen2004.logistic(conn)
x.out <- x.out %>% cbind(x.temp)
}
library(dplyr)
GongvLeeuwen2004.logistic <- function(x.input, connectivity.matrix, a = 1.7, eps = 0.8, order = 0){
# eps: coupling strength
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
# Higher orders are not implemented yet
#if(order) x <- x.input[,len-order:len]
# unit.vector allows to calculate M_i by multiplying it the connectivity matrix
unit.vector <- matrix(1, height, 1)
M <- connectivity.matrix %*% unit.vector
fx <- x.now %>% func.1() %>% as.matrix()
x.next <- (1 - eps)*fx + connectivity.matrix %*% fx*eps / M
x.next %>% return()
}
func.1 <- function(x, a = 1.7){1 - a*(x^2)}
library(dplyr)
library("Hmisc")
make.random.graph <- function(size = 20, num.links = 100, seed = 1){
set.seed(seed)
vals <- sample.int(size ^ 2, num.links + size)
diagonals <- c(1:size)#cbind(1:size,1:size)
edge.list <- cbind(vals %/% size + 0, vals %% size + 1)
for(i in  1:(num.links+size)){
if(edge.list[i,1]==edge.list[i,2]) edge.list[i,] <- NA
}
edge.list <- edge.list %>% na.omit()
# edge.list <- edge.list[1:num.links,]
#
# edge.list <- unique(edge.list[ , 1:2 ] )
edge.list.rev <- edge.list[,2] %>% cbind(edge.list[,1])
edge.list.symmetric <- edge.list %>% rbind(edge.list.rev)
edge.list.symmetric <- unique(edge.list.symmetric[ , 1:2 ] )
adj.matrix <- matrix(0, size, size)
adj.matrix[edge.list.symmetric] <- 1
# adj.matrix %>% sum() %>% sum()
#
# diag(adj.matrix)
adj.matrix %>% return()
}
library(dplyr)
seed <- 1
L_c <- 5200
N <- 300
T_ <- 6000
conn <- make.random.graph(size = N, num.links = L_c, seed = seed)
set.seed(seed)
x.init <- N %>% runif(-1,1)
x.out <- x.init
Sys.time()
for (i in 1:T_) {
x.temp <- x.out %>% GongvLeeuwen2004.logistic(conn)
x.out <- x.out %>% cbind(x.temp)
}
Sys.time()
save(x.out, file = "x.out_5200.300.6000.Rdata")
runif(1, 0, N)
sample.int(1,N)
sample.int(N,1)
sample.int(N,1)
sample.int(N,1)
sample.int(N,1)
sample.int(N,1)
sample.int(N,1)
set.seed(seed)
sample.int(N,1)
sample.int(N,1)
sample.int(N,1)
set.seed(seed)
set.seed(seed)
sample.int(N,1)
sample.int(N,1)
sample.int(N,1)
set.seed(seed)
i_ <- sample.int(N,1)
library(dplyr)
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
hight <- inp.dim[1]
leng <- inp.dim[2]
x.now <- x.input[,leng]
x.duplicated <- x.now
for (i in 1:(hight-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
d %>% return()
}
distances <- GongvLeeuwen2004.coherenceD(x.out[,T_+1],connectivity.matrix = conn)
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(hight-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
d %>% return()
}
distances <- GongvLeeuwen2004.coherenceD(x.out[,T_+1],connectivity.matrix = conn)
library(dplyr)
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
d %>% return()
}
distances <- GongvLeeuwen2004.coherenceD(x.out,connectivity.matrix = conn)
set.seed(seed)
i_ <- sample.int(N,1)
d_ <- distances[,i_]
j_2 <- max(d_)
j_1 <- min(d_)
d_ %>% max() %>% max()
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
diag(d) <- 1
d %>% return()
}
d_ <- distances[,i_]
j_1 <- min(d_)
j_2 <- max(d_)
d_ <- distances[,i_]
j_1 <- min(d_)
j_2 <- max(d_)
View(distances)
library(dplyr)
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
d %>% return()
}
d_ <- distances[,i_]
d_ <- d_[-i_]
j_1 <- min(d_)
j_2 <- max(d_)
?which.min
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
diag(d) <- NA
d %>% return()
}
d_ <- distances[,i_]
j_1 <- which.min(d_)
j_2 <- which.max(d_)
d_[i_]
diag(d) <- NA
d %>% return()
GongvLeeuwen2004.coherenceD <- function(x.input, connectivity.matrix){
inp.dim <- x.input %>% dim()
height <- inp.dim[1]
leng <- inp.dim[2]
if(!is.null(leng)) x.now <- x.input[,leng]
if(is.null(height)) height <- x.input %>% length()
if(is.null(leng)) x.now <- x.input
x.duplicated <- x.now
for (i in 1:(height-1)){x.duplicated <- x.now %>% cbind(x.duplicated)}
x.duplicated <- x.duplicated %>% as.matrix()
d <- (t(x.duplicated) - x.duplicated) %>% abs()
diag(d) <- NA
d %>% return()
}
View(distances)
distances <- GongvLeeuwen2004.coherenceD(x.out,connectivity.matrix = conn)
i_ <- sample.int(N,1)
d_ <- distances[,i_]
j_1 <- which.min(d_)
j_2 <- which.max(d_)
i_ <- sample.int(N,1)
d_ <- distances[,i_]
j_1 <- which.min(d_)
j_2 <- which.max(d_)
distances
distances[]
distances[i_,i_]
distances[i_,i_+1]
swap.edge <- function(connectivity.matrix, i1, j1, i2, j2){
edge.1 <- connectivity.matrix[i1,j1]
edge.2 <- connectivity.matrix[i2,j2]
connectivity.matrix[i1,j1] <- edge.2
connectivity.matrix[j1,i1] <- edge.2
connectivity.matrix[i2,j2] <- edge.1
connectivity.matrix[j2,i2] <- edge.1
connectivity.matrix %>% return()
}
library(dplyr)
swap.edge <- function(connectivity.matrix, i1, j1, i2, j2){
edge.1 <- connectivity.matrix[i1,j1]
edge.2 <- connectivity.matrix[i2,j2]
connectivity.matrix[i1,j1] <- edge.2
connectivity.matrix[j1,i1] <- edge.2
connectivity.matrix[i2,j2] <- edge.1
connectivity.matrix[j2,i2] <- edge.1
connectivity.matrix %>% return()
}
if(!conn[i_,j_1]) conn <- conn %>% swap.edge(i1 = i_, j1 = j_1, i2 = i_, j2 = j_2)
install.packages("igraph")
library(igraph)
graph_from_adjacency_matrix(conn, mode = "undirected")
g <- graph_from_adjacency_matrix(conn, mode = "undirected")
View(g)
g[[1]][[1]]
ClCoef <- transitivity(g)
ClCoef
tol <- 0.001
