l_
d_
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
conn
conn %>% sum() %>% sum
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
clustering.coef
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 10#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[3], seed = 1)
save(current.status, file = "current.status.20180224.2.RData")
seed <- 1
set.seed(seed)
num.edges <- 7#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
conn
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
View(rewired)
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef)
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef)
rewired <- NULL
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef)
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
#(clustering.coef[iterations] <- rewired$clustering.coef)
}
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
#(clustering.coef[iterations] <- rewired$clustering.coef)
}
rewired <- NULL
clustering.coef <- NULL
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
x
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g, type = "average")
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
?transitivity
time.end <- Sys.time()
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 7#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
rewired <- NULL
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix)
(clustering.coef[iterations] <- rewired$clustering.coef)
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[3], seed = 1)
save(current.status, file = "current.status.20180225.RData")
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix)
(clustering.coef[iterations] <- rewired$clustering.coef)
}
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix) %>% print()
(clustering.coef[iterations] <- rewired$clustering.coef) %>% print()
}
c(a1,a2) <- c(2,8)
c(a1,a2) <- c(2,8)
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g, type = "local")
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix) %>% print()
(clustering.coef[iterations] <- rewired$clustering.coef) %>% print()
}
?rewire
!conn[i_,k_]&T
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]&T) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g, type = "local")
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 7#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
rewired <- NULL
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix) %>% print()
(clustering.coef[iterations] <- rewired$clustering.coef) %>% print()
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[3], seed = 1)
save(current.status, file = "current.status.20180225.RData")
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps)
distances <- x.temp %>% Hellrigel2019.syncerror(connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
distances[i_,k_]
#if(!conn[i_,k_])
conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
library(dplyr)
make.random.graph <- function(size = 5, num.links = 10, distribution = "binary",
parameters = c(0,1), seed = 1){
set.seed(seed)
edges <- rep(0,size*(size-1)/2)
if(distribution == "binary"){
ones <- sample.int(length(edges), num.links)
edges[ones] <- 1
}
g <- matrix(0, size, size)
g[base::lower.tri(g, diag=FALSE)] <- edges
(adj.matrix <- g + t(g)) %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 15
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20# %>% as.vector()
num.epochs <- 1000#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(0,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
rewired <- NULL
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[1])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef) %>% sum() %>% print()
# iterations <- iterations + 1
}
rm(list = ls())
library(dplyr)
rm(list=ls())
source("./My Thesis Functions/April.GongvLeeuwen2004.R")
seed <- 1
# number of links
L_c <- 520
# number of nodes
N <- 3000 #3000
# number of iterations
T_ <- 600 #600
# tol <- 0.001
set.seed(seed)
conn <- make.random.graph(size = N, num.links = L_c, seed = seed)
x.init <- N %>% runif(-1,1) %>% t()
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
ClCoef <- igraph::transitivity(g)
GvL.start <- list(
x.tot = x.init,
clustering.coefficient = ClCoef,
connectivity.matrix = conn
)
GvL.finished <- GvL.start
for (i in 1:10){
print(i)
GvL.finished <- GvL.finished %>% GongvLeeuwen2004.adaptive.rewire()
g <- GvL.finished$connectivity.matrix %>% igraph::graph_from_adjacency_matrix(mode = "undirected")
(ClCoef <- igraph::transitivity(g)) %>% print()
}
View(GvL.finished)
GvL.finished$x.tot[1:10,1:10]
GvL.finished$x.tot[2,1:20]
GvL.finished$x.tot[,1] %>% sum()
GvL.finished$x.tot[,2] %>% sum()
GvL.finished$x.tot[1,10]
GvL.finished$x.tot[1,1:10]
GvL.finished$x.tot[,3] %>% sum()
GongvLeeuwen2004.logistic <- function(x.input,
connectivity.matrix,
a = 1.7,
eps = 0.8){
# eps: coupling strength
# eps <- 0.8
# x.input <- x.init
# connectivity.matrix <- conn
x.now <- x.input <- x.init
n.nodes <- x.now %>% ncol()
M <- connectivity.matrix %*% rep(1,n.nodes) %>% t()
fx <- x.now %>% func.1() %>% as.matrix()# %>% t()
neighbors <- fx %*% connectivity.matrix*eps / M
neighbors[is.nan(neighbors)] <- 0
x.next <- (1 - eps)*fx + neighbors
x.next %>% return()
}
library(dplyr)
rm(list=ls())
source("./My Thesis Functions/April.GongvLeeuwen2004.R")
seed <- 1
# number of links
L_c <- 520
# number of nodes
N <- 3000 #3000
# number of iterations
T_ <- 600 #600
set.seed(seed)
conn <- make.random.graph(size = N, num.links = L_c, seed = seed)
x.init <- N %>% runif(-1,1) %>% t()
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
ClCoef <- igraph::transitivity(g)
GvL.start <- list(
x.tot = x.init,
clustering.coefficient = ClCoef,
connectivity.matrix = conn
)
GvL.finished <- GvL.start
for (i in 1:10){
print(i)
GvL.finished <- GvL.finished %>% GongvLeeuwen2004.adaptive.rewire()
g <- GvL.finished$connectivity.matrix %>% igraph::graph_from_adjacency_matrix(mode = "undirected")
(ClCoef <- igraph::transitivity(g)) %>% print()
}
GvL.finished$x.tot[,3] %>% sum()
GvL.finished$x.tot[,2] %>% sum()
GvL.finished$x.tot[,2]
GvL.finished$x.tot[,6]
GvL.finished$x.tot[2,] - GvL.finished$x.tot[3,]
(GvL.finished$x.tot[2,] - GvL.finished$x.tot[3,]) %>% sum()
save.image
save.image()
