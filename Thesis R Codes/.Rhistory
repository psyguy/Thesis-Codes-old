conn
conn <- conn %>% swap.edge()
conn
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
conn
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
conn
k_val
k_
l_
d_
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
conn
conn %>% sum() %>% sum
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
clustering.coef
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
(clustering.coef <- transitivity(g))
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 10#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[3], seed = 1)
save(current.status, file = "current.status.20180224.2.RData")
seed <- 1
set.seed(seed)
num.edges <- 7#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
conn
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
clustering.coef[iterations] <- rewired$clustering.coef
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
View(rewired)
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef)
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef)
rewired <- NULL
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef)
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
#(clustering.coef[iterations] <- rewired$clustering.coef)
}
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
#(clustering.coef[iterations] <- rewired$clustering.coef)
}
rewired <- NULL
clustering.coef <- NULL
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
x
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g, type = "average")
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3]))
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
?transitivity
time.end <- Sys.time()
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 7#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
rewired <- NULL
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix)
(clustering.coef[iterations] <- rewired$clustering.coef)
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[3], seed = 1)
save(current.status, file = "current.status.20180225.RData")
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix)
(clustering.coef[iterations] <- rewired$clustering.coef)
}
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix) %>% print()
(clustering.coef[iterations] <- rewired$clustering.coef) %>% print()
}
c(a1,a2) <- c(2,8)
c(a1,a2) <- c(2,8)
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g, type = "local")
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix) %>% print()
(clustering.coef[iterations] <- rewired$clustering.coef) %>% print()
}
?rewire
!conn[i_,k_]&T
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient)
(x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps))
distances <- Hellrigel2019.syncerror(inp.x, connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
if(!conn[i_,k_]&T) conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g, type = "local")
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 1
set.seed(seed)
num.edges <- 7#5200
num.nodes <- 5#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 3#20 %>% as.vector()
num.epochs <- 10#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(-1,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
rewired <- NULL
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[3])
x <- rewired$x
(connectivity.matrix <- rewired$connectivity.matrix) %>% print()
(clustering.coef[iterations] <- rewired$clustering.coef) %>% print()
}
time.end <- Sys.time()
time.taken <- time.end - time.start
paste("It took", time.taken, "to run for", num.epochs, "epochs.") %>% print()
current.status <- list(rewired = rewired, clustering.coef = clustering.coef, num.epochs = num.epochs, eps = eps[3], seed = 1)
save(current.status, file = "current.status.20180225.RData")
my.rewiring <- function(inp.x, inp.conn, t.transient = 20, a = 1.7, eps = 0.8){
x.temp <- inp.x
conn <- inp.conn <- conn
for (i in 1:t.transient) x.temp <- x.temp %>% Hellrigel2019.logistic(conn, a = a, eps = eps)
distances <- x.temp %>% Hellrigel2019.syncerror(connectivity.matrix = conn)
num.nodes <- dim(inp.conn)[1]
i_ <- sample.int(num.nodes,1)
d_ <- distances[,i_]
k_val <- min(d_[-i_])
k_ <- which(d_==k_val)
l_ <- (d_ * conn[i_,]) %>% which.max()
distances[i_,k_]
#if(!conn[i_,k_])
conn <- conn %>% swap.edge(i_, k_, i_, l_)
# Skipped step 5 probabilistic approach
g <- igraph::graph_from_adjacency_matrix(conn, mode = "undirected")
clustering.coef <- transitivity(g)
output <- list(x = x.temp, connectivity.matrix = conn, clustering.coef = clustering.coef)
output %>% return()
}
library(dplyr)
make.random.graph <- function(size = 5, num.links = 10, distribution = "binary",
parameters = c(0,1), seed = 1){
set.seed(seed)
edges <- rep(0,size*(size-1)/2)
if(distribution == "binary"){
ones <- sample.int(length(edges), num.links)
edges[ones] <- 1
}
g <- matrix(0, size, size)
g[base::lower.tri(g, diag=FALSE)] <- edges
(adj.matrix <- g + t(g)) %>% return()
}
source("./My Thesis Functions/my.library.loader.R")
seed <- 15
set.seed(seed)
num.edges <- 5200
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20# %>% as.vector()
num.epochs <- 1000#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(0,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
rewired <- NULL
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[1])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef) %>% sum() %>% print()
# iterations <- iterations + 1
}
rm(list = ls())
source("./My Thesis Functions/my.library.loader.R")
seed <- 15
num.edges <- 5200
set.seed(seed)
num.nodes <- 300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20# %>% as.vector()
num.epochs <- 1000#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(0,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
rewired <- NULL
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[1])
x <- rewired$x
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef) %>% sum() %>% print()
# iterations <- iterations + 1
}
load("~/KUL/MPsy/Thesis - Stable/Thesis-Codes/Thesis R Codes/current.status.20180225.RData")
View(current.status)
View(current.status)
num.edges <- 5#5200
num.nodes <- 10#300
num.edges <- 30#5200
num.nodes <- 10#300
eps <- c(0.3, 0.4, 0.5)
a <- 1.7
t.transient <- 20# %>% as.vector()
num.epochs <- 1000#10000
tol <- 0.001
conn <- make.random.graph(size = num.nodes, num.links = num.edges,
dist = "binary", seed = seed)
x.init <- num.nodes %>% runif(0,1)
inp.x <- x.init
x <- x.init
connectivity.matrix <- conn
clustering.coef <- NULL
time.start <- Sys.time()
rewired <- NULL
t.transient <- 20# %>% as.vector()
num.epochs <- #1000#10000
tol <- 0.001
num.epochs <- 1#1000#10000
for(iterations in 1:num.epochs){
if(!(iterations %% 100)) paste("System time at iteration", iterations, "is", Sys.time()) %>% print()
rewired <- my.rewiring(inp.x = x, inp.conn = connectivity.matrix,
t.transient = t.transient, eps = eps[1])
(x <- rewired$x) %>% print()
connectivity.matrix <- rewired$connectivity.matrix
(clustering.coef[iterations] <- rewired$clustering.coef) %>% sum() %>% print()
# iterations <- iterations + 1
}
x.init <- N %>% runif(-1,1)
x.out <- x.init
T_ <- 60#00
for (i in 1:T_) {
x.temp <- x.out %>% GongvLeeuwen2004.logistic(conn)
x.out <- x.out %>% cbind(x.temp)
}
View(x.out)
View(x.out)
?transitivity
?mirt::empirical_ES
getwd()
